#ifndef XML_ELEMENT_INFO_CPP
#define XML_ELEMENT_INFO_CPP

//---------------------------------------------------------------------
//    ___
//   /\__\    This file is part of MUSE    <http://www.muse-tools.org/>
//  /::L_L_
// /:/L:\__\  Miami   University  Simulation  Environment    (MUSE)  is
// \/_/:/  /  free software: you can  redistribute it and/or  modify it
//   /:/  /   under the terms of the GNU  General Public License  (GPL)
//   \/__/    as published  by  the   Free  Software Foundation, either
//            version 3 (GPL v3), or  (at your option) a later version.
//    ___
//   /\__\    MUSE  is distributed in the hope that it will  be useful,
//  /:/ _/_   but   WITHOUT  ANY  WARRANTY;  without  even  the IMPLIED
// /:/_/\__\  WARRANTY of  MERCHANTABILITY  or FITNESS FOR A PARTICULAR
// \:\/:/  /  PURPOSE.
//  \::/  /
//   \/__/    Miami University  and  the MUSE  development team make no
//            representations  or  warranties  about the suitability of
//    ___     the software,  either  express  or implied, including but
//   /\  \    not limited to the implied warranties of merchantability,
//  /::\  \   fitness  for a  particular  purpose, or non-infringement.
// /\:\:\__\  Miami  University and  its affiliates shall not be liable
// \:\:\/__/  for any damages  suffered by the  licensee as a result of
//  \::/  /   using, modifying,  or distributing  this software  or its
//   \/__/    derivatives.
//
//    ___     By using or  copying  this  Software,  Licensee  agree to
//   /\  \    abide  by the intellectual  property laws,  and all other
//  /::\  \   applicable  laws of  the U.S.,  and the terms of the  GNU
// /::\:\__\  General  Public  License  (version 3).  You  should  have
// \:\:\/  /  received a  copy of the  GNU General Public License along
//  \:\/  /   with MUSE.  If not,  you may  download  copies  of GPL V3
//   \/__/    from <http://www.gnu.org/licenses/>.
//
//---------------------------------------------------------------------

#include "XMLElementInfo.h"
#include "XMLElement.h"
#include <iostream>
#include <QDebug>
#include <QStringList>
#include <QDateTime>

// List of key-value pairs used to populate TypeNameMap.
// This list would not be needed under c++11
const char* XMLElementInfo::TypeNameList[] = {
    "7QString", "QString", "i", "int", "l", "long", "f", "float",
    "d", "double", "P10XMLElement", "XMLElement",
    NULL, NULL // Do not remove this last line!
};

// Convenience dictionary to map type names generated by various compilers
// to suitable types in Qt
QHash<QString, QString> XMLElementInfo::TypeNameMap;

// Static constant to conveniently refer to an invalid element info
const XMLElementInfo XMLElementInfo::Invalid;

// Static constant for formatting date values to/from XML.
const QString XMLElementInfo::XmlDateFormat = "yyyy-MM-dd";

// Static constant for formatting time values to/from XML.
const QString XMLElementInfo::XmlTimeFormat = "hh:mm:ss.z";

// Static constant for formatting date-time values to/from XML.
const QString XMLElementInfo::XmlDateTimeFormat = "yyyy-MM-ddThh:mm:ss.z";

// Default constructor is protected to ensure it is never called directly.
XMLElementInfo::XMLElementInfo() : name(""), type(QMetaType::Void),
    isList(false), pointer(NULL) {
    // Setup the TypeNameMap for rapid type look-ups (done only once)
    if (TypeNameMap.empty()) {
        for(int i = 0; (TypeNameList[i] != NULL); i += 2) {
            TypeNameMap[TypeNameList[i]] = TypeNameList[i + 1];
        }
    }
}

// The copy constructor
XMLElementInfo::XMLElementInfo(const XMLElementInfo &src) :
    name(src.name), type(src.type), isList(src.isList), pointer(src.pointer) {
    // Nothing else to be done here.
}

XMLElementInfo::XMLElementInfo(const QString &name, bool *pointer) :
    name(name), type(QMetaType::Bool), isList(false), pointer(pointer) {
    // Nothing else to be done in this constructor.
}

XMLElementInfo::XMLElementInfo(const QString &name, QString *pointer) :
    name(name), type(QMetaType::QString), isList(false), pointer(pointer) {
    // Nothing else to be done in this constructor.
}

XMLElementInfo::XMLElementInfo(const QString &name, int *pointer) :
    name(name), type(QMetaType::Int), isList(false), pointer(pointer) {
    // Nothing else to be done in this constructor.
}

XMLElementInfo::XMLElementInfo(const QString &name, long *pointer) :
    name(name), type(QMetaType::Long), isList(false), pointer(pointer) {
    // Nothing else to be done in this constructor.
}

XMLElementInfo::XMLElementInfo(const QString &name, double *pointer) :
    name(name), type(QMetaType::Double), isList(false), pointer(pointer) {
    // Nothing else to be done in this constructor.
}

XMLElementInfo::XMLElementInfo(const QString &name, QDate *pointer) :
    name(name), type(QMetaType::QDate), isList(false), pointer(pointer) {
    // Nothing else to be done in this constructor.
}

XMLElementInfo::XMLElementInfo(const QString &name, QTime *pointer) :
    name(name), type(QMetaType::QTime), isList(false), pointer(pointer) {
    // Nothing else to be done in this constructor.
}

XMLElementInfo::XMLElementInfo(const QString &name, QDateTime *pointer) :
    name(name), type(QMetaType::QDateTime), isList(false), pointer(pointer) {
    // Nothing else to be done in this constructor.
}

XMLElementInfo::XMLElementInfo(const QString &name, XMLElement *pointer) :
    name(name), type(QMetaType::User), isList(false), pointer(pointer) {
    // Nothing else to be done in this constructor.
}

XMLElementInfo::XMLElementInfo(const QString &name, QStringList *pointer) :
    name(name), type(QMetaType::QString), isList(true), pointer(pointer) {
    // Nothing else to be done in this constructor.
}

XMLElementInfo::~XMLElementInfo() {
    if (isList && isUserType()) {
        QList<XMLElement*>& list =
            *reinterpret_cast<QList<XMLElement*>*>(pointer);
        for(int i = 0; (i < list.size()); i++) {
            delete list[i];
        }
        
    }
}

int
XMLElementInfo::getType(const QString& typeName) {
    // Check if we have a valid mapping. If so, we are all set.
    if (TypeNameMap.contains(typeName)) {
        int qtTypeId = QMetaType::type(TypeNameMap[typeName].toStdString().c_str());
        if (qtTypeId == QMetaType::UnknownType) {
            std::cerr << "A valid type mapping for type " << typeName.toStdString()
                      << " was not found in Qt. Ensure the type is registered.\n";
            Q_ASSERT(qtTypeId != QMetaType::UnknownType);  // Will fail, per design
        }
        return qtTypeId;
    }
    // When control drops here, then we don't have a known mapping.
    // Let's try to see if the default typename works out.
    const int qtTypeId = QMetaType::type(typeName.toStdString().c_str());
    // If a default mapping did not work out, report an error.
    if (qtTypeId == QMetaType::Void) {
        std::cerr << "A valid type mapping for type " << typeName.toStdString()
                  << " was not found. Add a suitable entry in "
                  << "XMLElementInfo::TypeNameList. Aborting!\n";
        Q_ASSERT(qtTypeId != QMetaType::Void);
    }
    // Found a valid type id. Perfect.
    return qtTypeId;
}

void
XMLElementInfo::addValue(XMLElement *value) {
    if (!isList || !isUserType() || (pointer == NULL)) {
        return; // cannot perform the operation.
    }
    static_cast<QList<XMLElement*>*>(pointer)->append(value);
}

void
XMLElementInfo::setValue(const QString &value) {
    if (pointer == NULL) {
        return; // Value is ignored.
    }
    if (isList) {
        // For list we have a helper method to add values.
        addValue(value);
        return;
    }
    switch (type) {
    case QMetaType::QString:
        *static_cast<QString*>(pointer) = value; break;
    case QMetaType::Bool:
        *static_cast<bool*>(pointer) = toBool(value); break;
    case QMetaType::Int:
        *static_cast<int*>(pointer) = value.toInt();  break;
    case QMetaType::Long:
        *static_cast<long*>(pointer) = value.toLong(); break;
    case QMetaType::Double:
        *static_cast<double*>(pointer) = value.toDouble(); break;
    case QMetaType::QDate:
        *static_cast<QDate*>(pointer) = QDate::fromString(value, XmlDateFormat);
        break;
    case QMetaType::QTime:
        *static_cast<QTime*>(pointer) = QTime::fromString(value, XmlTimeFormat);
        break;
    case QMetaType::QDateTime:
        *static_cast<QDateTime*>(pointer) =
            QDateTime::fromString(value, XmlDateTimeFormat);
        break;
    default:
        qDebug() << "Unhandled QMetaType countered in "
                    "XMLElementInfo::setOneValue() method.";
    }
}

bool
XMLElementInfo::toBool(const QString &value) {
    return QString::compare("false", value, Qt::CaseInsensitive);
}

QString
XMLElementInfo::fromBool(const bool value) {
    return (value ? "true" : "false");
}

void
XMLElementInfo::addValue(const QString &value) {
    if ((pointer == NULL) || (!isList)) {
        return; // Value is ignored.
    }
    switch (type) {
    case QMetaType::QString:
        static_cast<QStringList*>(pointer)->push_back(value);
        break;
    case QMetaType::Bool:
        static_cast<QList<bool>*>(pointer)->append(toBool(value));
        break;
    case QMetaType::Int:
        static_cast<QList<int>*>(pointer)->append(value.toInt());
        break;
    case QMetaType::Long:
        static_cast<QList<long>*>(pointer)->append(value.toLong());
        break;
    case QMetaType::Double:
        static_cast<QList<double>*>(pointer)->append(value.toDouble());
        break;
    case QMetaType::QDate:
        static_cast<QList<QDate>*>(pointer)->append(QDate::fromString(value, XmlDateFormat));
        break;
    case QMetaType::QTime:
        static_cast<QList<QTime>*>(pointer)->append(QTime::fromString(value, XmlTimeFormat));
        break;
    case QMetaType::QDateTime:
        static_cast<QList<QDateTime>*>(pointer)->append(QDateTime::fromString(value, XmlDateTimeFormat));
        break;
    default:
        qDebug() << "Unhandled QMetaType countered in "
                    "XMLElementInfo::addToList() method.";
    }
}

QString
XMLElementInfo::getValue() const {
    Q_ASSERT(pointer != NULL);
    switch (type) {
    case QMetaType::QString:
        return *static_cast<QString*>(pointer);
    case QMetaType::Bool:
        return fromBool(*static_cast<bool*>(pointer));
    case QMetaType::Int:
        return QString::number(*static_cast<int*>(pointer));
    case QMetaType::Long:
        return QString::number(*static_cast<long*>(pointer));
    case QMetaType::Double:
        return QString::number(*static_cast<double*>(pointer));
    case QMetaType::QDate:
        return static_cast<QDate*>(pointer)->toString(XmlDateFormat);
    case QMetaType::QTime:
        return static_cast<QTime*>(pointer)->toString(XmlTimeFormat);
    case QMetaType::QDateTime:
        return static_cast<QDateTime*>(pointer)->toString(XmlDateTimeFormat);
    }
    return "";
}

QString
XMLElementInfo::getValue(const int index) const {
    Q_ASSERT(pointer != NULL);
    switch (type) {
    case QMetaType::QString:
        return static_cast<QStringList*>(pointer)->value(index);
    case QMetaType::Bool:
        return fromBool(static_cast<QList<bool>*>(pointer)->value(index));
    case QMetaType::Int:
        return QString::number(static_cast<QList<int>*>(pointer)->value(index));
    case QMetaType::Long:
        return QString::number(static_cast<QList<long>*>(pointer)->value(index));
    case QMetaType::Double:
        return QString::number(static_cast<QList<double>*>(pointer)->value(index));
    case QMetaType::QDate:
        return static_cast<QList<QDate>*>(pointer)->value(index).toString(XmlDateFormat);
    case QMetaType::QTime:
        return static_cast<QList<QTime>*>(pointer)->value(index).toString(XmlTimeFormat);
    case QMetaType::QDateTime:
        return static_cast<QList<QDateTime>*>(pointer)->value(index).toString(XmlDateTimeFormat);
    default:
        qDebug() << "Unhandled QMetaType countered in "
                    "XMLElementInfo::getValue(const int) method.";
    }
    return "";
}

int
XMLElementInfo::getListSize() const {
    if (!isList) {
        // This is not a list element!
        return -1;
    }
    if (isUserType()) {
        // Handle lists of user types
        return reinterpret_cast<QList<XMLElement*>*>(pointer)->size();
    }
    switch (type) {
    case QMetaType::QString:
        return reinterpret_cast<QStringList*>(pointer)->size();
    case QMetaType::Bool:
        return reinterpret_cast<QList<bool>*>(pointer)->size();
    case QMetaType::Int:
        return reinterpret_cast<QList<int>*>(pointer)->size();
    case QMetaType::Long:
        return reinterpret_cast<QList<long>*>(pointer)->size();
    case QMetaType::Double:
        return reinterpret_cast<QList<double>*>(pointer)->size();
    case QMetaType::QDate:
        return reinterpret_cast<QList<QDate>*>(pointer)->size();
    case QMetaType::QTime:
        return reinterpret_cast<QList<QTime>*>(pointer)->size();
    case QMetaType::QDateTime:
        return reinterpret_cast<QList<QDateTime>*>(pointer)->size();
    default:
        qDebug() << "Unhandled QMetaType countered in "
                    "XMLElementInfo::getListSize() method.";
    }
    return -1;
}

const XMLElement*
XMLElementInfo::getSubElement(const int index) const {
    if (isList && isUserType()) {
        return reinterpret_cast<QList<XMLElement*>*>(pointer)->value(index);
    }
    return NULL;
}

XMLElement*
XMLElementInfo::getSubElement(const int index) {
    if (isList && isUserType()) {
        return reinterpret_cast<QList<XMLElement*>*>(pointer)->value(index);
    }
    return NULL;
}

#endif
