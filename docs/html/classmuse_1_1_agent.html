<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>MUSE(MiamiUniversitySimulationEngine): muse::Agent Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacemuse.html">muse</a>::<a class="el" href="classmuse_1_1_agent.html">Agent</a>
  </div>
</div>
<div class="contents">
<h1>muse::Agent Class Reference</h1><!-- doxytag: class="muse::Agent" -->The base class for all agents in a simulation.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;agent.h&gt;</code>
<p>
<div class="dynheader">
Collaboration diagram for muse::Agent:</div>
<div class="dynsection">
<p><center><img src="classmuse_1_1_agent__coll__graph.png" border="0" usemap="#muse_1_1_agent__coll__map" alt="Collaboration graph"></center>
<map name="muse_1_1_agent__coll__map">
<area shape="rect" href="structmuse_1_1_agent_i_d_type.html" title="The AgentID struct." alt="" coords="5,5,147,32"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classmuse_1_1_agent-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmuse_1_1_agent.html#dc9dd3a5678d8ced93a30ee6ca59fd0e">initialize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The initialize method.  <a href="#dc9dd3a5678d8ced93a30ee6ca59fd0e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmuse_1_1_agent.html#d9845a266dd73c5adadf76b41ad4e56d">finalize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The finalize method.  <a href="#d9845a266dd73c5adadf76b41ad4e56d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmuse_1_1_agent.html#be4d3cd4b92ff367761248aa9ed8fcf7">executeTask</a> (const <a class="el" href="namespacemuse.html#083f558503d5c106aa28daec5ee3549f">EventContainer</a> &amp;events)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The executeTask method.  <a href="#be4d3cd4b92ff367761248aa9ed8fcf7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmuse_1_1_agent.html#5cfd3f02f5b9b52d53417c92a2fa03c1">scheduleEvent</a> (const <a class="el" href="classmuse_1_1_event.html">Event</a> &amp;e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The scheduleEvent method.  <a href="#5cfd3f02f5b9b52d53417c92a2fa03c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="structmuse_1_1_agent_i_d_type.html">AgentID</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmuse_1_1_agent.html#09cfa84fa1109533dd1a5f4d954bd0c7">getAgentID</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The getAgentID method returns a pointer to AgentID struct.  <a href="#09cfa84fa1109533dd1a5f4d954bd0c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classmuse_1_1_time.html">Time</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmuse_1_1_agent.html#91dff47fd113ccd7ca296a5099727740">getSimulationTime</a> (<a class="el" href="namespacemuse.html#daf3920593c9b4ea89b137cd547b32a6">TimeType</a> type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The getSimulationTime method returns a pointer to <a class="el" href="classmuse_1_1_time.html" title="The Time class.">Time</a>, which contains NOW time by default.  <a href="#91dff47fd113ccd7ca296a5099727740"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmuse_1_1_agent.html#bad703ed8b3343b8239b276560c36900">createAgent</a> (const <a class="el" href="classmuse_1_1_agent.html">Agent</a> &amp;agent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method is used for dynamically creating agents.  <a href="#bad703ed8b3343b8239b276560c36900"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmuse_1_1_agent.html#695f23b3df237e85037afa1002d749a9">migrateAgent</a> (const <a class="el" href="structmuse_1_1_agent_i_d_type.html">AgentID</a> &amp;otherAgentID)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The migrateAgent method will move this agent to another <a class="el" href="classmuse_1_1_simulation.html" title="The Simulation Class.">Simulation</a> Engine?  <a href="#695f23b3df237e85037afa1002d749a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmuse_1_1_agent.html#0cf72dfc49eae10eb97d444dddad2eb8">unregisterAgent</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The unregisterAgent method is used to remove this agent from the simulation.  <a href="#0cf72dfc49eae10eb97d444dddad2eb8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structmuse_1_1_stream_type.html">Stream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmuse_1_1_agent.html#2fde7206e08cbeef49d96b2f517911fb">createStreamer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The createStream method, will return a pointer to a Stream type.  <a href="#2fde7206e08cbeef49d96b2f517911fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classmuse_1_1_state.html">State</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmuse_1_1_agent.html#431ae651d3c7a61b245d438d3b20a1d7">cloneState</a> (const <a class="el" href="classmuse_1_1_state.html">State</a> &amp;state)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The cloneState method will return a <a class="el" href="classmuse_1_1_state.html" title="The State class.">State</a> * which will be a copy of this agents <a class="el" href="classmuse_1_1_state.html" title="The State class.">State</a>.  <a href="#431ae651d3c7a61b245d438d3b20a1d7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmuse_1_1_agent.html#10cc028911f0de3f483a2c32d85a6658">serialize</a> (std::ostream &amp;os)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The serialize method is used to serialize this agent to a given output stream.  <a href="#10cc028911f0de3f483a2c32d85a6658"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmuse_1_1_agent.html#70feffd10fbef5d733335fcbbf6f9d88">Agent</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The ctor.  <a href="#70feffd10fbef5d733335fcbbf6f9d88"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmuse_1_1_agent.html#1a7cf49cae78866480eee86e598bf46a">~Agent</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The dtor.  <a href="#1a7cf49cae78866480eee86e598bf46a"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The base class for all agents in a simulation. 
<p>
This class represents the base class from which all user-defined simulation agents must be derived. This class provides several methods that expose the core functionality of a <a class="el" href="namespacemuse.html" title="The muse namespace.">muse</a> simulation. In addition, the user is expected to implement some of the methods in this class. Refer to the documentation associated with each method for details on the functionality and requirements of the variuos methods in this class.<p>
To create an agent for your simulation, make sure you derive from this <a class="el" href="classmuse_1_1_agent.html" title="The base class for all agents in a simulation.">Agent</a> Class, Also be sure to override all methods that are declared virtual. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="70feffd10fbef5d733335fcbbf6f9d88"></a><!-- doxytag: member="muse::Agent::Agent" ref="70feffd10fbef5d733335fcbbf6f9d88" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">muse::Agent::Agent           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The ctor. 
<p>
The ctor is not supposed to be overriden. <dl compact><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>make sure that the above statement is a accurate statement. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1a7cf49cae78866480eee86e598bf46a"></a><!-- doxytag: member="muse::Agent::~Agent" ref="1a7cf49cae78866480eee86e598bf46a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">muse::Agent::~Agent           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The dtor. 
<p>
The dtor is not supposed to be overriden. <dl compact><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>make sure that the above statement is a accurate statement. </dd></dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="dc9dd3a5678d8ced93a30ee6ca59fd0e"></a><!-- doxytag: member="muse::Agent::initialize" ref="dc9dd3a5678d8ced93a30ee6ca59fd0e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void muse::Agent::initialize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The initialize method. 
<p>
This method is invoked whenever just when a simulation commences. The core simulation engine invokes this mehtod. This mehtod may perform any agent specific initialization activites that may be necessary. This includes opening new streams for performing I/O.<p>
NOTE: Whenever a new agent is created, clients should override this method. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::exception</em>&nbsp;</td><td>This method throws an exception when errors occur. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d9845a266dd73c5adadf76b41ad4e56d"></a><!-- doxytag: member="muse::Agent::finalize" ref="d9845a266dd73c5adadf76b41ad4e56d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void muse::Agent::finalize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The finalize method. 
<p>
This method is invoked once the simulation has finished processing all events and is ending. The core simulation engine invokes this method. This method may perform any final clean up or displaying results, basic I/O.<p>
NOTE: Whenever a new agent is created, clients should override this method. 
</div>
</div><p>
<a class="anchor" name="be4d3cd4b92ff367761248aa9ed8fcf7"></a><!-- doxytag: member="muse::Agent::executeTask" ref="be4d3cd4b92ff367761248aa9ed8fcf7" args="(const EventContainer &amp;events)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void muse::Agent::executeTask           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemuse.html#083f558503d5c106aa28daec5ee3549f">EventContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>events</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The executeTask method. 
<p>
This method is invoked only when the agent has some events to process. The events that this agent must process at a given time step is all passed in one single shot to this method.<p>
Note: That this method must not modify the events passed in. Note: Whenever a new agent is created, clients should override this method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>events</em>&nbsp;</td><td>The set of concurrent (events at the same time) events that this method should process.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="namespacemuse.html#083f558503d5c106aa28daec5ee3549f" title="The EventContainer.">EventContainer</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5cfd3f02f5b9b52d53417c92a2fa03c1"></a><!-- doxytag: member="muse::Agent::scheduleEvent" ref="5cfd3f02f5b9b52d53417c92a2fa03c1" args="(const Event &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool muse::Agent::scheduleEvent           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmuse_1_1_event.html">Event</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The scheduleEvent method. 
<p>
This method is used to schedule an event to be processed by any agent. It takes the given <a class="el" href="classmuse_1_1_event.html" title="The base class for all events in a simulation.">Event</a> and first checks if<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>e</em>&nbsp;</td><td>this is an <a class="el" href="classmuse_1_1_event.html" title="The base class for all events in a simulation.">Event</a> object and will not be modified by this method. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>bool this will let the client know if the operation was a success.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>Event() </dd></dl>

</div>
</div><p>
<a class="anchor" name="09cfa84fa1109533dd1a5f4d954bd0c7"></a><!-- doxytag: member="muse::Agent::getAgentID" ref="09cfa84fa1109533dd1a5f4d954bd0c7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structmuse_1_1_agent_i_d_type.html">AgentID</a>* muse::Agent::getAgentID           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The getAgentID method returns a pointer to AgentID struct. 
<p>
This method is used to return a pointer to a AgentID struct which contains the id of the agent. Once pointer is obtained, simple using the command <a class="el" href="structmuse_1_1_agent_i_d_type.html#567456fbc742755a46fc5d3df786a71d" title="enum value id.">AgentID.id</a> would extract the actual id, but for all purpose the client should have no reason to do this, unless the id is required for I/O purposes. All method that require will only take of type AgentID.<p>
Note: All agents must register with the muse::Simulator which in returns assigns an AgentID. This AgentID is what this method will be returning a pointer to.<p>
Note: AgentID that is returned should not be modified in anyway.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>AgentID * </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="namespacemuse.html#f6de347b0a066bd8c82033f80b84ac87" title="The AgentID struct.">AgentID</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="91dff47fd113ccd7ca296a5099727740"></a><!-- doxytag: member="muse::Agent::getSimulationTime" ref="91dff47fd113ccd7ca296a5099727740" args="(TimeType type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmuse_1_1_time.html">Time</a>* muse::Agent::getSimulationTime           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemuse.html#daf3920593c9b4ea89b137cd547b32a6">TimeType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The getSimulationTime method returns a pointer to <a class="el" href="classmuse_1_1_time.html" title="The Time class.">Time</a>, which contains NOW time by default. 
<p>
This method is used to return a pointer to a <a class="el" href="classmuse_1_1_time.html" title="The Time class.">Time</a> struct which contains the simulation time. By default it will return the simulation time of NOW, optional params will be of type Enum TimeType. Possible value to pass in are enum { NOW, START_TIME, END_TIME}; START_TIME is the time when the simualtion started, note does not have to be zero (0), but does have to be a positive. END_TIME is the time when the simulation will end, again this must be a positive value thats equal to or greater then the START_TIME.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>this is an Enum called TimeType. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="classmuse_1_1_time.html" title="The Time class.">Time</a> * </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>Time() <p>
<a class="el" href="namespacemuse.html#daf3920593c9b4ea89b137cd547b32a6" title="The Enum TimeType.">TimeType</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="bad703ed8b3343b8239b276560c36900"></a><!-- doxytag: member="muse::Agent::createAgent" ref="bad703ed8b3343b8239b276560c36900" args="(const Agent &amp;agent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool muse::Agent::createAgent           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmuse_1_1_agent.html">Agent</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>agent</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method is used for dynamically creating agents. 
<p>
This methos is used for creating agents during the simulation. When an agent is created via this method, it will automatically be registered to the <a class="el" href="classmuse_1_1_simulation.html" title="The Simulation Class.">Simulation</a> Engine of its parent agent. Parent <a class="el" href="classmuse_1_1_agent.html" title="The base class for all agents in a simulation.">Agent</a> is the agent that is creating the agent. In the future, this restriction might be lefted, but for now it's what it is. Once this agent is registered, it losses all ties to the parent agent.<p>
Note: the <a class="el" href="classmuse_1_1_agent.html" title="The base class for all agents in a simulation.">Agent</a> passed in will not be modified in anyway, except the assignment of an AgentID.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>agent</em>&nbsp;</td><td>this is of type <a class="el" href="classmuse_1_1_agent.html" title="The base class for all agents in a simulation.">Agent</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>bool true if the operation was successful </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classmuse_1_1_agent.html" title="The base class for all agents in a simulation.">Agent</a> </dd></dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>remove the const from the param </dd></dl>

</div>
</div><p>
<a class="anchor" name="695f23b3df237e85037afa1002d749a9"></a><!-- doxytag: member="muse::Agent::migrateAgent" ref="695f23b3df237e85037afa1002d749a9" args="(const AgentID &amp;otherAgentID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool muse::Agent::migrateAgent           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmuse_1_1_agent_i_d_type.html">AgentID</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>otherAgentID</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The migrateAgent method will move this agent to another <a class="el" href="classmuse_1_1_simulation.html" title="The Simulation Class.">Simulation</a> Engine? 
<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>figure out if we want to use an AgentID or a <a class="el" href="structmuse_1_1_simulator_i_d.html" title="The SimulatorID struct.">SimulatorID</a>.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>?</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>bool true if the operation was a success. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>? </dd></dl>

</div>
</div><p>
<a class="anchor" name="0cf72dfc49eae10eb97d444dddad2eb8"></a><!-- doxytag: member="muse::Agent::unregisterAgent" ref="0cf72dfc49eae10eb97d444dddad2eb8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool muse::Agent::unregisterAgent           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The unregisterAgent method is used to remove this agent from the simulation. 
<p>
Not much to document about this method. Once this is called there will be no way to get this agent back, so use this with CAUTION! When this is called all info containing this agent will be removed, this includes <a class="el" href="classmuse_1_1_state.html" title="The State class.">State</a> info, which could lead to a rollback.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>bool true if operation was successful. </dd></dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>figure out a way to make sure simulation will not go into rollback because of this call.</dd></dl>

</div>
</div><p>
<a class="anchor" name="2fde7206e08cbeef49d96b2f517911fb"></a><!-- doxytag: member="muse::Agent::createStreamer" ref="2fde7206e08cbeef49d96b2f517911fb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmuse_1_1_stream_type.html">Stream</a>* muse::Agent::createStreamer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The createStream method, will return a pointer to a Stream type. 
<p>
Note sure what this Stream type will be yet??? <dl compact><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>fix this methods doc, when I have a better idea of the Stream type.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Stream * </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="namespacemuse.html#bf1dd76aeff3cb85920b06803ce57387" title="The Stream struct.">Stream</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="431ae651d3c7a61b245d438d3b20a1d7"></a><!-- doxytag: member="muse::Agent::cloneState" ref="431ae651d3c7a61b245d438d3b20a1d7" args="(const State &amp;state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmuse_1_1_state.html">State</a>* muse::Agent::cloneState           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmuse_1_1_state.html">State</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>state</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The cloneState method will return a <a class="el" href="classmuse_1_1_state.html" title="The State class.">State</a> * which will be a copy of this agents <a class="el" href="classmuse_1_1_state.html" title="The State class.">State</a>. 
<p>
Since every agent has a <a class="el" href="classmuse_1_1_state.html" title="The State class.">State</a> there is no need to pass in the <a class="el" href="classmuse_1_1_state.html" title="The State class.">State</a> object to be cloned, this info can be derived from the <a class="el" href="classmuse_1_1_agent.html" title="The base class for all agents in a simulation.">Agent</a> object. This method will return a <a class="el" href="classmuse_1_1_state.html" title="The State class.">State</a> object. This method will simply call <a class="el" href="classmuse_1_1_state.html#27ea592fc77edccbf699da3f07ac1951" title="the getClone method.">State.getClone()</a>, which should be implemented by the client.<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>remove the params because it is not needed. </dd></dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>figure out if we really need the return type to be const </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>State() </dd></dl>

</div>
</div><p>
<a class="anchor" name="10cc028911f0de3f483a2c32d85a6658"></a><!-- doxytag: member="muse::Agent::serialize" ref="10cc028911f0de3f483a2c32d85a6658" args="(std::ostream &amp;os)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool muse::Agent::serialize           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The serialize method is used to serialize this agent to a given output stream. 
<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>figure out exactly what it means to serial an agent????</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>this is of type std::ostream </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>bool true if operation is successful </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>include/agent.h</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Sep 16 14:16:10 2008 for MUSE(MiamiUniversitySimulationEngine) by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
