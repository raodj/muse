/*
 * Script to extract data from raw simulation runs to perform
 * Generalized Sensitivity Analysis (GSA) as dicussed in article:
 * "Identifying the critical parameters of a cyanobacterial growth and
 * movement model by using generalised sensitivity analysis", by Basak
 * Guven and Alan Howard, doi:10.1016/j.ecolmodel.2007.03.024 (see
 * Section 6 of paper).  

 * The data for this script is the raw logs generated by
 * sensitivity/calibration program sens-anal. Specifically, the log is
 * assumed to be in a CSV format to identify columns to be used for
 * computing F-measure.
 *
 * This program performs the following tasks for GSA:
 *
 * 1. Uses 3 specified columns; one for the variable being explored
 * and the other two for timings of two different queues.
 * 2. Identifies unique parameter values from 1st column-number.
 *    2.1. For each unique parameter setting it counts number of
 *         success (time1 <= time2) and failures.
 *    2.2. It computes percentage success and cumulative percentage success.
 *    2.3. It computes percentage failure and cumulative percentage failure.
 * 3. Reports difference between cumulative success and failure, with
 *    the highest difference being reported as the sensitivity metric.
 */

#include <iostream>
#include <string>
#include <utility>
#include <vector>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <map>
#include <random>
#include <chrono>

// The maximum number of acceptable lows count
const int LowsThresh = 0;

// A simple structure that holds the parameter value, time1, time2.
struct ParamTimes {
    double param;  // value for parameter
    double time1;  // Runtime from one type of scheduler queue (ladderQ)
    double time2;  // Runtime from alternative type of scheduler queue (heap2tQ)
};

// The vector that holds raw data in the form of ParamErr pairs
using ParamTimesList = std::vector<ParamTimes>;

// Structure to encapsulate each row of information in GSA table.
struct GSAEntry {
    GSAEntry() : param(0), success(0), percSuccess(0), cumlPercSuccess(0),
                 failed(0), percFailed(0), cumlPercFailed(0), diff(0) {}
    void add(double paramVal, double succ, double fail) {
        param = paramVal;
        success += succ;
        failed += fail;
    }
    double param;
    double success;
    double percSuccess;
    double cumlPercSuccess;
    double failed;
    double percFailed;
    double cumlPercFailed;
    double diff;
};

// Use map for ordered list of keys to iterate over
using GSATable = std::map<double, GSAEntry>;

class GSA {
public:
    GSA(int paramCol, int time1Col, int time2Col) :
        paramCol(paramCol), time1Col(time1Col), time2Col(time2Col) {}

    bool loadData(const std::string& logFilePath);

    GSATable computeGSAtable(const ParamTimesList& rawData) const;
    void printResults(const GSATable& gsaTab,
                      std::ostream& os = std::cout) const;
    void printGSAtable(std::ostream&os = std::cout) const;
    double computeStdErr(const double bootSize = 1.0,
                         const int reps = 5000) const;
    void printCI(std::ostream& os = std::cout) const;
    GSAEntry getMaxEntry(const GSATable& gsaTab) const;
    
protected:
    ParamTimes extract(std::string line);
    ParamTimesList randomSample(const ParamTimesList& rawData,
                              const size_t num) const;
    bool isGSAUseful(const GSATable& gsaTab) const;
private:
    ParamTimesList rawData;
    int paramCol;   // 0-based column for parameter to process
    int time1Col;   // negative values indicate index from last column
    int time2Col;   // negative values indicate index from last column
};

double round(double val) {
    long value = val * 1000;
    return (value / 1000.0);
}

ParamTimes
GSA::extract(std::string line) {
    std::vector<std::string> wordList;
    std::string word;
    // Extract words into a vector
    std::istringstream is(line);
    while (std::getline(is, word, ',')) {
        wordList.push_back(word);
    }
    // Setup the final column numbers based on number of columns we have
    const int MaxCol       = wordList.size();
    const int lineTime1Col = (time1Col < 0 ? (MaxCol + time1Col) : time1Col);
    const int lineTime2Col = (time2Col < 0 ? (MaxCol + time2Col) : time2Col);
    // Get the numeric values from the corresponding colums
    const double param = std::stod(wordList[paramCol]);
    const double time1 = std::stod(wordList[lineTime1Col]);
    const double time2 = std::stod(wordList[lineTime2Col]);
    // Return encapsulating object back
    return ParamTimes({param, time1, time2});
}

GSATable
GSA::computeGSAtable(const ParamTimesList& rawData) const {
    GSATable gsaTab;
    double totSucc = 0, totFail = 0;  // total success & failures
    // First compute success/failure counts for each unique param value.
    for (const ParamTimes& pts : rawData) {
        // time1 == ladderQ, time2 == heap2tQ
        if (pts.time1 >= pts.time2) {
            gsaTab[pts.param].add(pts.param, 1, 0);
            totSucc++;
        } else {
            gsaTab[pts.param].add(pts.param, 0, 1);
            totFail++;
        }
    }
    // Now compute the cumulative percentages and values
    GSAEntry prevEntry;
    for (auto& iter : gsaTab) {
        GSAEntry& entry   = iter.second;
        entry.percSuccess = (totSucc > 0 ? (entry.success / totSucc) : 0);
        entry.percFailed  = (totFail > 0 ? (entry.failed  / totFail) : 0);
        entry.cumlPercSuccess = prevEntry.cumlPercSuccess + entry.percSuccess;
        entry.cumlPercFailed = prevEntry.cumlPercFailed  + entry.percFailed;
        entry.diff          = std::abs(entry.cumlPercSuccess - entry.cumlPercFailed);
        // Set prevEntry for next iteraton
        prevEntry = entry;
    }
    return gsaTab;
}

GSAEntry
GSA::getMaxEntry(const GSATable& gsaTab) const {
    GSAEntry maxEntry = gsaTab.begin()->second;
    for (const auto& iter : gsaTab) {
        const GSAEntry& ent = iter.second;
        if (ent.diff > maxEntry.diff) {
            maxEntry = ent;
        }
    }
    return maxEntry;
}

bool
GSA::loadData(const std::string& logFilePath) {
    std::ifstream logFile(logFilePath);
    if (!logFile.good()) {
        std::cerr << "Error reading log file: " << logFilePath << std::endl;
        return false;
    }
    // Read line by line and extract the necessary column information
    std::string line;
    while (std::getline(logFile, line)) {
        if (line.empty() || (line.at(0) == '#')) {
            continue;  // blank line or comment line. Skip it.
        }
        ParamTimes pel = extract(line);
        rawData.push_back(pel);
    }
    return true; // success
}

ParamTimesList
GSA::randomSample(const ParamTimesList& rawData, const size_t num) const {
    std::default_random_engine gen(std::chrono::system_clock::now().time_since_epoch().count());
    std::uniform_int_distribution<int> rnd(0, rawData.size() - 1);    
    ParamTimesList subData;
    while (subData.size() < num) {
        const int index = rnd(gen);
        subData.push_back(rawData.at(index));
    }
    return subData;
}

double
GSA::computeStdErr(const double bootSz, const int reps) const {
    std::vector<double> fList;
    const int bootSize = rawData.size() * bootSz;
    for (int rep = 0; (rep < reps); rep++) {
        ParamTimesList subRawData = randomSample(rawData, bootSize);
        GSATable subTab = computeGSAtable(subRawData);
        // Get f-measure entry
        GSAEntry maxEntry = getMaxEntry(subTab);
        fList.push_back(maxEntry.diff);
    }
    // Now compute variance in f-measures
    const double fMean = std::accumulate(fList.begin(),
                                         fList.end(), 0.0) / reps;
    double diffSum = 0;
    for (double f : fList) {
        const double diff = fMean - f;
        diffSum += (diff * diff);
    }
    const double stderr = std::sqrt(diffSum / (reps - 1));
    return stderr;
}

void
GSA::printCI(std::ostream& os) const {
    os << "StdErr: " << computeStdErr() << std::endl;
}

bool
GSA::isGSAUseful(const GSATable& gsaTab) const {
    // Get last entry in the table that has full/cumulative data
    GSATable::const_iterator last = --gsaTab.end();
    return ((last->second.cumlPercSuccess > 0) &&
            (last->second.cumlPercFailed > 0));
}

void
GSA::printResults(const GSATable& gsaTab, std::ostream& os) const {
    const std::string sep = ",";
    os << "# ParamVal, success, %success, %cuml_success, failure, "
       << "%failure, %cuml_failure, diff, #entries\n";
    for (const auto& iter : gsaTab) {
        const GSAEntry& ent = iter.second;
        const int sum = ent.success + ent.failed;
        os << ent.param << sep << ent.success << sep << ent.percSuccess
           << sep << ent.cumlPercSuccess << sep << ent.failed << sep
           << ent.percFailed << sep << ent.cumlPercFailed << sep
           << ent.diff << sep << sum << std::endl;
    }
    // Compute 95% confidence interval
    const double ci = computeStdErr() * 1.96;
    // Print trailing line used by gnuplot plotting scripts
    const GSAEntry maxEntry = getMaxEntry(gsaTab);
    os << "#Max F: param_val cumlPerSucc cumlPerFail f-measure boot_strap_ci\n";
    // The f-measure we compute is meanigful only if we have non-zero
    // total success & failure. If one of them is zero, then print 0
    // to indicate this parameter has no influence at all.
    if (isGSAUseful(gsaTab)) {
        os << "# " << maxEntry.param  << " " << maxEntry.cumlPercSuccess << " "
           << maxEntry.cumlPercFailed << " " << maxEntry.diff << " "
           << ci << std::endl;
    } else {
        // F-measure not useful. So diff = 0, ci = 0 (100% confidence)
        os << "# " << maxEntry.param  << " " << maxEntry.cumlPercSuccess << " "
           << maxEntry.cumlPercFailed << " 0 0\n";        
    }
}

void
GSA::printGSAtable(std::ostream&os) const {
    const GSATable gsaTab = computeGSAtable(rawData);
    printResults(gsaTab, os);
}

int main(int argc, char *argv[]) {
    if (argc < 4) {
        std::cerr << "Incorrect number of arguments specified. Expected:\n"
                  << "  1: The SA output log file to process.\n"
                  << "  2: Column number (0-based) of parameter to process.\n"
                  << "  3: Queue1 (ladderQ) timing column (0-based)\n"
                  << "  4: Queue2 (heap2tQ) timing column (0-based)\n";
        return 1;
    }
    // Setup column numbers to streamline code below
    const int paramCol = std::stoi(argv[2]);
    const int time1Col = std::stoi(argv[3]);
    const int time2Col = std::stoi(argv[4]);
    // Have the GSA class load raw data
    GSA gsa(paramCol, time1Col, time2Col);
    if (!gsa.loadData(argv[1])) {
        return 2;
    }
    // Now that raw data has been successfully loaded, compute the
    // f-measure
    gsa.printGSAtable();
    return 0;
}
